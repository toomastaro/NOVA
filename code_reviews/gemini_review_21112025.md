# Анализ проекта Nova Bot

## 1. Общее описание проекта

**Nova Bot** — это платформа (SaaS-решение) для создания и управления Telegram-ботами. Архитектура проекта построена на базе **Python 3.12**, **FastAPI** (для приема вебхуков) и **Aiogram 3.x** (для логики ботов). В качестве базы данных используется **PostgreSQL** с использованием **SQLAlchemy** (asyncio).

### Структура проекта
Проект имеет монолитную структуру, разделенную на логические модули:

*   **`main_api.py`**: Точка входа. FastAPI приложение, которое принимает вебхуки от Telegram. Оно маршрутизирует обновления либо в `main_bot` (админская/платформенная часть), либо в `hello_bot` (пользовательские боты), создавая экземпляры ботов на лету.
*   **`config.py`**: Управление конфигурацией через переменные окружения (`.env`) и жестко заданные тарифы.
*   **`main_bot/`**: Логика основного бота-платформы. Содержит обработчики, работу с БД (пользователи, платежи, статистика), админку.
*   **`hello_bot/`**: Логика пользовательских ботов (инстансов). Реализует функционал для конечных пользователей (приветствия, защита чатов, управление каналами).
*   **`utils/`**: Общие утилиты и middleware.
*   **`Dockerfile` / `docker-compose.yml`**: Инфраструктура для развертывания.

---

## 2. Анализ качества кода и архитектуры

### Проблемные места (Critical & Major)

1.  **Производительность БД (Critical)**:
    *   В `utils/middleware.py` в классе `SetCrud` вызывается `await other_db.create_tables()` **на каждый запрос (update)**. Это колоссальная нагрузка на базу данных. Проверка схемы должна выполняться при старте или миграциях, а не в рантайме обработки сообщений.
    *   **Паттерн доступа к данным**: Используется "God Object" (класс `Database`, наследующий все CRUD-миксины). Методы `fetch/execute` создают **новую сессию** на каждый запрос. Это делает невозможным выполнение транзакций, охватывающих несколько операций (Atomicity), и увеличивает оверхед на создание подключений.

2.  **Обработка ошибок и Логирование (Major)**:
    *   В коде (особенно в `hello_bot`) часто встречается конструкция `try...except Exception as e: print(e)`. Это "гасит" ошибки, не позволяя отследить их в системах мониторинга (Sentry подключен в зависимостях, но используется не везде).
    *   `print()` используется вместо структурированного логгера. В Docker-среде это затрудняет анализ логов.

3.  **Архитектура приложения**:
    *   Жесткая связность: `main_api.py` знает и о `main_bot`, и о `hello_bot`. При масштабировании это станет узким местом.
    *   Хранение состояния: `dispatchers = {}` в глобальной области видимости `main_api.py`. При перезапуске сервиса все кешированные диспетчеры теряются (что нормально), но при горизонтальном масштабировании (несколько реплик API) это вызовет рассинхрон.

4.  **Безопасность**:
    *   **Docker**: Контейнер запускается от `root` (по умолчанию), хотя в `entrypoint.sh` есть попытки работы с UID/GID. Рекомендуется явно создавать пользователя в Dockerfile.
    *   **SQL Injection**: Использование SQLAlchemy ORM защищает от большинства инъекций, но стоит проверить места, где параметры передаются в raw SQL (если есть).

### Положительные моменты
*   Использование современного стека (Python 3.12, Aiogram 3, SQLAlchemy 2.0).
*   Наличие типизации (Type Hints) в большинстве мест.
*   Модульная структура папок (handlers, database, keyboards).
*   Использование `.env` для секретов.

---

## 3. Переход на микросервисную архитектуру

Текущий монолит можно разделить на следующие сервисы:

1.  **Gateway Service (Webhook Handler)**:
    *   Принимает вебхуки от Telegram.
    *   Кладет обновления в очередь сообщений (RabbitMQ / Kafka / Redis Streams).
    *   Максимально легкий и быстрый.

2.  **Main Bot Worker**:
    *   Читает очередь `main_bot_updates`.
    *   Обрабатывает логику платформы (оплата, админка).

3.  **User Bot Worker(s)**:
    *   Читает очередь `user_bot_updates`.
    *   Обрабатывает логику пользовательских ботов (`hello_bot`).
    *   Может масштабироваться горизонтально (много воркеров).

4.  **Scheduler Service**:
    *   Вынесенный планировщик задач (APScheduler) для рассылок и проверок подписок.

**Преимущества**:
*   Отказоустойчивость: падение одного бота не кладет все API.
*   Масштабируемость: можно добавить воркеров для пользовательских ботов при росте нагрузки.
*   Деплой: можно обновлять логику ботов без простоя приема вебхуков.

---

## 4. Список "Быстрых побед" (Quick Wins)

Эти изменения дадут максимальный эффект при минимальных затратах времени:

1.  **Убрать `create_tables` из middleware**: Перенести создание таблиц в скрипт инициализации или миграции (Alembic). Это мгновенно ускорит обработку запросов.
2.  **Заменить `print` на `logger`**: Использовать `loguru` везде.
3.  **Добавить `pre-commit` хуки**: Black, Isort, Flake8 для автоматического форматирования.
4.  **Настроить `Sentry`**: Глобальный перехват исключений в middleware, чтобы видеть реальные ошибки.
5.  **Fix Docker User**: Добавить создание пользователя `appuser` в Dockerfile.

---

## 5. План работ (Sprints)

Каждый спринт рассчитан на 2 дня.

### Спринт 1: Стабилизация и Логирование
*   **День 1**:
    *   [x] Настройка `loguru`: замена всех `print(e)` на `logger.error`.
    *   [x] Удаление `await other_db.create_tables()` из `SetCrud` middleware. Вынос инициализации БД в `lifespan` или отдельный скрипт.
*   **День 2**:
    *   [x] Подключение Sentry для всех необработанных исключений.
    *   [x] Рефакторинг `Dockerfile`: запуск от не-root пользователя.
    *   [x] Настройка `.pre-commit-config.yaml` (linting).

### Спринт 2: Рефакторинг Базы Данных
*   **День 1**:
    *   [x] Внедрение **Alembic** для управления миграциями. Создание начальной миграции.
    *   [x] Рефакторинг `DatabaseMixin`: переход на передачу `session` в методы (Dependency Injection) вместо создания сессии внутри методов.
*   **День 2**:
    *   [x] Исправление логики транзакций (Unit of Work). Обеспечение атомарности операций (например, создание юзера и настроек в одной транзакции).
    *   [x] Оптимизация пула соединений в `config.py` / `db.py`.

### Спринт 3: Тестирование и CI
*   **День 1**:
    *   [x] Настройка `pytest` и `pytest-asyncio`.
    *   [x] Написание тестов для критических сценариев `hello_bot` (join request, welcome message).
*   **День 2**:
    *   [x] Настройка GitHub Actions / GitLab CI: линтинг и прогон тестов при пуше.
    *   [x] Написание тестов для биллинга (тарифов) в `main_bot`.

### Спринт 4: Подготовка к микросервисам (Архитектура)
*   **День 1**:
    *   [x] Внедрение Redis. Настройка кеширования для `dispatchers` и сессий пользователей.
    *   [x] Разделение логики: четкое выделение интерфейсов между API и Bot Logic.
*   **День 2**:
    *   [x] Прототип очереди задач (RabbitMQ/Redis) для отложенных действий (например, рассылок), замена `asyncio.sleep`.

---

## Заключение
Проект имеет хороший потенциал и современный стек, но страдает от типичных "болезней роста" (монолитность, проблемы с производительностью БД, отсутствие observability). Реализация плана "Быстрых побед" критически важна перед любым добавлением нового функционала.
